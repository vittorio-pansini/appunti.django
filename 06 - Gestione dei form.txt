***********************
06 - Gestione dei form
     [2.0.1]
***********************

Il form è l'interfaccia web per ricevere l'input da parte dell'utente.

Esso ha degli attributi che spercificano a quale URL il browser deve inviare i dati e quale metodo deve utilizzare per inviare i dati, metodi che possono essere GET o POST.

La differenza fra l'uno e l'altro metodo è nel tipo di HttpRequest che viene fatta al nostro sito web: in modo molto sintetico, possiamo affermare che GET invia i dati all'interno della URL stessa (insieme all'indirizzo della pagina che richiamiamo, con i dati che sono direttamente leggibili sulla barra degli indirizzi), mentre POST li implementa nel corpo della HttpRequest stessa.

In altre parole se stiamo eseguendo una pagina che presenta un form, quando questa viene semplicemente richiamata dal browser o da un'altra pagina della nostra applicazione o facciamo il refresh della pagina, la richiesta che arriva alla view è di tipo GET; quando facciamo confermiamo la nostra pagina web, invece, la classe/funzione view riceve una una richiesta di tipo POST.

Questo significa che, nel codice della view possiamo distinguere i due tipi di richiesta in modo differente, ad esempio attivando i controlli formali nel blocco "POST" e facendo altre cose nel blocco "GET".


Gestione del form da HTML
-------------------------

In questo paragrafo accenniamo ai controlli che sono gestiti all'interno dei form, così come da specifiche HTML5

Il form è racchiuso fra i tag   <form>...</form>  e contiene tre attributi fondamentali:

	• method	che può assumere i valori "get" o "post" come detto.
	
	• action	che contiene l'URL cui inviare i dati; se omesso per default il
				form che riceve i dati è lo stesso che li invia.
	
	• enctype	indica il tipo di codifica da utilizzare e viene impostato di
				solito quando l'input è usato per fare l'upload di file, ad
				esempio di immagini; "application/x-www-form-urlencoded" è il
				valore di default, ovvero l'input generico e può essere omesso,
				mentre "multipart/form-data" indica l'upload.

All'interno del form possono esservi diversi elementi che costituiscono l'input da parte dell'utente; ciascun elemento è individuato da un identificativo, una stringa che viene indicata all'interno con l'attributo  id="..." e che serve ad identificare univocamente l'oggetto DOM per la gestione dei dati che vi confluiscono.

Da notare che esiste un altro attributo di identificazione,  name="..."  che funziona similmente, ma differisce da "id" per il fatto che quest'ultimo è utilizzato per identificare UNIVOCAMENTE un elemento nel DOM e pertanto non dovrebbero esistere più elementi con lo stesso id; è invece possibile avere più elementi con lo stesso valore "name", utile se si vuole gestire un gruppo di elementi in forma di array di oggetti. Normalmente è buona abitudine usare "id" e "name" con lo stesso valore.

In HTML5, come retaggio del passato, textbox, check box e perfino pulsanti sono gestiti con il tag generico   <input ..... >   che ha perso la necessità di avere un tag di chiusura </input> e affida invece il suo funzionamento ai vari attributi che differenziano il suo aspetto e funzionamento.

In particolare il valore type indica il tipo di oggetto che deve essere renderizzato nella pagina del browser; ad onor del vero l'approccio di descrivere il tag <input> è meno funzionale e dunque in questi appunti si cercherà invece di differenziare l'input per modalità.

Ecco di seguito l'elenco degli elementi maggiormente utilizzati negli input:


• LABEL		
	
	Le label servono per indicare all'utente il tipo di input richiesto e differiscono dal semplice testo perchè è il browser che gestisce il loro posizionamento a seconda dell'input stesso; il testo della label va posto fra i tag   <label>...</label>
	
	Un attributo fondamentale della label è  for="..."  che si usa per agganciare la label all'elemento di input relativo; se abbiamo dato ad un checkbox id="mioCheck" con for="mioCheck" andiamo ad "agganciare" la label a detto checkbox.
	
	Esempio:
	
		<label for="nome">Nome utente:</label>
	
	
• TEXTBOX

	L'input di tipo testo è gestito dal tag  <input> con l'attributo type="..." che determina i seguenti comportamenti:
	
		"text"			input di testo in chiaro

		"password"		input di testo celato di tipo password

		"number"		input di un numero intero che ha anche dei pulsanti per
						incrementare/decrementare il valore.

		"search"		usato per i campi di ricerca

		"tel"			usato per input di numeri di telefono
		
		"email"			input controllato per gli indirizzi email
		
		"url"			usato per input di URL

		"date"			casella di testo speciale che gestisce le date con la
						comparsa di un calendario a discesa; è possibile usare
						gli attributi stringa "min" e "max" per consentire di
						porre un limite alle date in input.

		"datetime-local"	come "date" ma con in più la gestione dell'ora
		
		"month"			input controllato per mese ed anno come "date"
						
		"time"			usato per input di orari, come "date"
		
		"week"			usato per input del numero di settimana
		
	Si noti che molte di queste caselle di input sembrerebbero rindondanti; in realtà l'uso di un "type" specifico fa risparmiare molta fatica sia perchè il rendering viene fatto direttamente dal browser, sia perchè è il browser stesso a VALIDARE il contenuto.
	
	Come vedremo, infatti, sarà importante capire se il form viene tornato in modalità "valid" o meno nella view che andremo a creare.
	

	Esempi:
	
		<input type="text" id="username" name="username">
		<input type="password" id="pwd" name="pwd">
		<input type="date" id="compleanno" name="compleanno">
		<input type="number" id="quantity" name="quantity" 
			   min="0" max="100" step="10" value="30">

• CHECKBOX

	I checkbox sono realizzati ancora dal tag="input" e type="checkbox" e possono essere associati ad un valore che viene restituito in output. Esempio:
	
		<input type="checkbox" id="veicolo" name="veicolo" value="Automobile">
	
	
• RADIOBOX	
	
	I radiobox definiti da type="radio" devono essere gestiti in gruppi, che a loro volta sono individuati dallo stesso tag "name", come si vede nell'esempio che segue:
	
		<input type="radio" id="html"
			name="linguaggio" value="HTML">
				<label for="html">HTML</label><br>

		<input type="radio" id="css"
			name="linguaggio" value="CSS">
				<label for="css">CSS</label><br>

		<input type="radio" id="javascript"
			name="fav_language" value="JavaScript">
				<label for="javascript">JavaScript</label>


• COLOR

	Questo input, attivato con type="color", viene gestito interamente dal browser e serve a ricavare un valore esadecimale che si riferisce ad un colore selezionato. 
	
	A seconda del supporto del browser, nel campo di input può essere visualizzato un selettore di colori.
	
		<input type="color" id="mioColore" name="mioColore">
	

• RANGE

	Definito dal type="range", si tratta di un selettore a slide che consente di accettare un input da un valore minimo ad uno massimo, utile per fornire un sistema intuitivo di input di un valore numerico.
	
		<input type="range" id="vol" name="vol" min="0" max="50">


• FILE

	L'input definito da type="file", consente di recuperare il percorso sul sistema dell'utente ed è utile per l'upload o la selezione di file che debbano essere successivamente letti.
	
	Si tratta di un input gestito completamente dal browser di solito sotto forma di pulsante e finestra di dialogo nello stile preimpostato all'interno del browser stesso.
	
		<input type="file" id="mioFile" name="mioFile">


• HIDDEN

	Quello definito da type="hidden" non è un input controllato dall'utente, ma definisce un campo di input nascosto (non visibile all'utente).
	
	Un campo nascosto spesso memorizza il record del database che deve essere aggiornato quando viene inviato il modulo e consente agli sviluppatori Web di includere dati che non possono essere visualizzati o modificati dagli utenti quando viene inviato un modulo.

	Anche se il valore non viene mostrato all'utente nel contenuto della pagina, è visibile (e modificabile) utilizzando gli strumenti di sviluppo di qualsiasi browser o la funzionalità "Visualizza sorgente", quindi è sconsigliato nella gestione di elementi di sicurezza.

		<input type="hidden" id="idUtente" name="idUtente" value="3487">


Quelli che seguono NON sono veri e propri campi di input, ma dei tag che consentono di gestire il form; i browser li gestiscono tipicamente come dei pulsanti che generano a loro volta una specifica azione.


• SUBMIT

	Il tag "input" con type="submit" definisce un pulsante per inviare i dati del modulo a un gestore del modulo.

	Il gestore del modulo è in genere una pagina del server con uno script per l'elaborazione dei dati di input ed è specificato nell'attributo "action" che va inserita nel tag "form" di appartenenza.
	
		<form action="/action_submit_page.php">
			
			{ ... }
			
			<input type="submit" value="Conferma">
		</form>


• BUTTON

	Con type="button" definiamo un pulsante svincolato dall'azione di conferma del form e a quella che andiamo a definire manualmente, ad esempio tramite l'attributo onclick, come nell'esempio che segue.

		<input type="button" onclick="alert('Ciao mondo!')" value="Cliccami!">


• RESET

	Il controllo definito da type="reset" definisce un pulsante che ripristinerà tutti i valori del modulo ai valori predefiniti.
	
		<input type="reset" value="Reinizializza">


A molti degli input dei tipi descritti, e a seconda della loro tipologia, si applicano i seguenti attributi:

	id				identifica univocamente l'input da gestire
	
	placeholder		frase di uggerimento che compare sul campo prima dell'input
	
	name			nome del campo di input
	
	value			valore di default del campo

	disabled		specifica che un campo deve essere disabilitato

	max 			valore massimo di input

	maxlength 		numero massimo di caratteri inseribili

	min 			valore minimo di input

	pattern 		espressione regolare con cui controllare il valore di input
					
	readonly 		specifica se il campo è di sola lettura (non modificabile)
					
	required 		specifica se un campo di input è obbligatorio 
					
	size 			larghezza (in caratteri) di un campo di input
	
	step 			intervalli numerici per un input numerico

	checked			specifica che il checkbox o il ratiobox deve essere spuntato


• DROPDOWN LIST

	La dropdown list ha una struttura costituita da diversi tag. Osserviamo il prossimo esempio:
	
		<select id="modello" name="modello">
			<optgroup label="Primo gruppo">
				<option value="1">Primo elemento</option>
				<option value="2">Secondo elemento</option>
			</optgroup>
			<optgroup label="Secondo gruppo">
				<option value="3">Terzo elemento</option>
				<option value="4">Quarto elemento</option>
			</optgroup>
		</select>

	Il tag "select" racchiude la stuttura della dropdown list, mentre gli elementi selezionabili sono individuati dai vari tag "option" che individuano ciascuno un attributo "value" che è quello che viene poi acquisito dal form.
	
	Opzionalmente, come si vede nell'esempio, è possibile raggruppare i vari elementi dando un nome al gruppo (la label); la label compare fra gli elementi, evidenziata ma non selezionabile.


• LISTBOX

	E' simile alla dropdown list ma presenta i vari elementi in un'area più ampia, con la possiblità di poterne fare anche una selezione multipla. Per ottenere la list box si usa la stessa identica struttura della dropdown list e si aggiunge l'attributo "multiple" al tag "select", come segue:
	
		<select id="modello" name="modello" multiple>
			.....
		</select>
	
	L'utente potrà usare la combinazione CTRL+click o SHIFT+click per selezionare più di un elemento della lista, tranne le label dei gruppi.
	

• TEXT AREA

	Il tag "textarea" consente di predisporre un'area di testo libero nella quale l'utente può introdurre del testo che contiene anche i ritorni a capo e senza limite di lunghezza.

		<textarea name="area_testo" id="area_testo"></textarea>

	Si noti che nel caso del tag "textarea" va comunque inserito il tag di chiusura </textarea>.
	


Il Djagno Form Library
----------------------

Anzichè produrre il form su HTML e poi gestirlo dall'esterno, Django mette a disposizione una libreria che consente di creare la struttura del nostro form dall'interno del codice, che poi viene "consegnata" al template, che si occupa poi della costruzione vera e propria di tutti i tag che abbiamo visto precedentemente.

Come vedremo nel prossimo esempio, erediteremo la classe  django.forms.Form  nella nostra classe view e ciò ci consentirà di costruire letteralmente e gestire i controlli che andiamo poi a mettere nel nostro form.

Per prima cosa creiamo un nuovo file in .../Hello/feed   che chiamiamo  form_gestiti.py  e che conterrà il seguente codice:

	from django import forms
	
	class FormUno(forms.Form):

		nome_utente = forms.CharField()
		password = forms.CharField(widget=forms.PasswordInput)
	
La classe FormUno() eredita la classe forms.Form e contiene due campi; il primo è un imput di testo normale, il secondo è un testo di tipo password.

La definizione avviene tramite assengazione ad una proprietà della classe della proprietà ereditata da Form; nel primo caso la classe FormUno è di tipo Form e contiene una proprietà (diciamo una variabile) chiamata nome_utente di tipo CharField.

Ogni volta che assegnamo una proprietà dentro la nostra classe, andiamo a creare un campo esattamente come se lo scrivessimo in html, solo in modo più semplice e gestendo il nostro form come un oggetto.

Ora che abbiamo creato la classe FormUno() dobbiamo implementarla nella classe che gestisce la nostra view; quindi dobbiamo aprire il file di gestione views.py ed andiamo prima ad importare il nostro file dei form ...

	from django.shortcuts import render
	from . import forms_gestiti

... poi andiamo a creare una istanza di FormUno e ad usarla nella classe (o funzione) che gestisce la view ...

	def form01(request):

		istanzaForm = forms_gestiti.FormUno()
		return render(request, "mioForm.html", {"form": istanzaForm})

Come si vede dal codice, viene creata l'istanza di FormUno che si chiama istanzaForm e viene passata al render della pagina di destinazione, che sarà presente fra i template col nome di "mioForm.html"; l'istanza è passata col nome di "form", semplicemente.

La funzione form01 riceve il parametro "request", una parola chiave che include proprietà e metodi di HttpRequest e WSGIRequest, fra cui, come vedremo, abbiamo le proprietà request.GET e request.POST 

Andiamo a creare l'url che ci serve in .../Hello/url.py come abbiamo già visto...

	...
		path('form01', feed.views.form01, name='form01'),
	...

... ed infine andiamo a creare l'html template di destinazione .../Hello/templates/mioForm.html che avrà un aspetto molto semplice:

	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Form di prova</title>
	</head>
	<body>
		<h1>Form di prova</h1>

		<form method="POST" action="">

			{% csrf_token %}

			<table>
				{{ form.as_table }}
			</table>

			<div>
				<button type="submit">Conferma</button>
			</div> 

		</form>
	</body>
	</html>

Il form è di tipo "POST" e con il parametro action impostato a "" indichiamo che l'azione è presente nello stesso form di appartenenza.


Notiamo poi la presenza di un elemento speciale {% csrf_token %}. Questo elemento è un vero e proprio token che serve a Django per superare quello che viene definito come vulnerabilità di tipo "Cross Site Request Forgery".

Il Cross-site request forgery, abbreviato CSRF (o anche XSRF), è una vulnerabilità a cui sono esposti i siti web dinamici quando sono progettati per ricevere richieste da un client senza controllare se la richiesta sia stata inviata intenzionalmente oppure no. In sintesi consente ad un intruso che controlla un sito malevolo di inviare richieste autenticate a nome della vittima, abusando così dei suoi privilegi presso un servizio online.

Inserendo il token nel form, Django considererà il post generato dal form come attendibile ed accetterà il submit dell'utente; viceversa un submit da parte di un agente malevolo esterno (una web page che imita il nostro submit) che NON conterrà il token verrà automaticamente ignorato.


Quando Djagno va a renderizzare il form, va a creare automaticamente tutti gli input che abbiamo definito nella classe FormUno, nel punto esatto dove abbiamo inserito il costrutto  {{ form.as_table }} , fra i tag <table></table>.

Nel caso specifico notiamo che i campi sono completi di label e perfettamente incolonnati come su una tabella; questa è la modalità di default, ma possiamo avere altre modalità:

	{{ ###.as_ul }} 	costruisce una struttura puntata fra i tag <ul></ul>.
	
	{{ ###.as_p }} 		costruisce una struttura a paragrafi, senza tag.

Una volta completato tutto, avviando Django e raggiungendo la pagina che richiama il form notiamo che abbiamo ottenuto il risultato voluto.

Ora chiudiamo il cerchio "traducendo" tutte le precedenti specifiche in quelle date dalla libreria dei form di Django:

	Elemento		Django Form library
	-------------------------------------------------------------------------------

	LABEL			La label viene generata automaticamente mettendo il nome della
					variabile che viene assengata, oppure inserendo il parametro
					label="..." alla proprietà durante l'assegnazione.

	TEXTBOX			forms.CharField()								  testo normale
					forms.CharField(widget=forms.PasswordInput) 	  tipo password
					forms.IntegerField()						 	  numero intero
					forms.FloatField()	o forms.FloatField()     numero con virgola
					forms.EmailField()										  email
					forms.DateField(input_formats = ['%d/m/%y', '%d/m/%Y'])	   
					forms.DateField(widget=forms.DateInput(attrs={'type': 'date'}))
					forms.DateTimeField(widget=forms.DateTimeInput
												(attrs={'type': 'datetime-local'}))
					forms.DateTimeField(widget=forms.DateTimeInput
														 (attrs={'type': 'month'}))
					forms.DateTimeField(widget=forms.DateTimeInput
														  (attrs={'type': 'time'}))
					forms.DateTimeField(widget=forms.DateTimeInput
														  (attrs={'type': 'week'}))
					forms.CharField(widget=forms.URLField)			  indirizzi url

	CHECKBOX		forms.BooleanField()

	DROPDOWN LIST	forms.ChoiceField(choices=LISTA) dove l'argomento è una lista
					o tupla contentente una coppia di stringhe valore+descrizione.

	LISTBOX			forms.MultipleChoiceField(choices=LISTA) come il dropdown list.

	RADIOBOX		forms.ChoiceField(choices=LISTA, widget=forms.RadioSelect) 
					anche in questo caso si usa una lista di coppie di argomenti
					e il parametro widget per indicare il tipo di input.
					
	TEXT AREA		forms.CharField(widget=forms.Textarea)  si indica il tipo
					CharField con indicazione del testo.

	HIDDEN			forms.CharField(widget=forms.HiddenInput, initial='valore')

	COLOR			-	type="color"

	RANGE			-	type="range"

	FILE			-	type="file"


Di seguito le specifiche degli attributi, che nel caso di Django Form Library vengono passati nelle parentesi di specifica del singolo campo.

	id				id = '...'
	placeholder		help_text = '...'
	name			assunto il nome del campo
	value			initial = '...'
	disabled		disabled = True / False
	max 			max_value = ...
	maxlength 		max_length = ...
	min 			min_value = ...
	required 		required = True / False
	checked			initial = True

I tag submit, button e reset vanno inseriti a mano come già visto precedentemente nella pagina html.






quando andiamo a creare la view


Dato che AddPostView eredita da FormView una serie di proprietà e metodi già preconfezionati e che hanno valori e comportamenti già predeterminati, vale la pena di dare una attenta lettura della documentazione della libreria (usando ad esempio il citato su http://ccbv.co.uk).

Andiamo a valorizzare alcune importante variabili:

	template_name  al solito indica la pagina "fisica" che verrà gestita da Django 
	               e che andremo a creare nel prossimo passaggio.

	form_class     è la classe gestita dalla view, definita nel passaggio precedente 
	               ed inserita fra gli import; in questo caso la classe PostForm.

	success_url    è la pagina da aprire in caso di successo, nel nostro caso la 
	               homepage, cioè "/".



























Caricamento di file
-------------------

Con l'esempio che segue consentiremo all'utente di inserire un nuovo post che verrà pubblicato sulla home page, formato da un commento e da una immagine jpeg, caricata dall'esterno.

Se già non l'abbiamo creato, nel corso dell'esempio precedente, per prima cosa creiamo un nuovo file in .../Hello/feed   che chiamiamo  form.py  e che conterrà il seguente codice:

	from django import forms
	
	class PostForm(forms.Form):
		text = forms.CharField()
		image = forms.FileField()

La classe PostForm() eredita la classe forms.Form e contiene due campi (fields), il primo è un testo di commento, il secondo è l'upload di un file. Aggiungiamo ora la nostra view operando sul file .../Hello/feed/views.py

	...
		path('addpost', feed.views.AddPostView, name='addpost'),
	...

Anche questa sarà una view basata sulle classi e per la precisione sulla classe FormView, che andiamo ad importare. Importeremo anche PostForm dal file locale forms.py che abbiamo appena creato.

	from django.views.generic  import ...., FormView
	from .forms import PostForm
	.......
	class AddPostView(FormView):
		template_name = "new_post.html"
		form_class = PostForm
		success_url ="/"
		
		def form_valid(self, form):
		
			new_object = Post.objects.create(
				text = form.cleaned_data['text'],
				image = form.cleaned_data['image']
			)
		
			return super().form_valid(form)

		
Nella stessa classe andiamo a creare un metodo, ovvero a fare l'overload del metodo ereditato form_valid() ed in questo nostro metodo facciamo due cose: andiamo a creare un nuovo oggetto Post; usando un vecchio gergo, possiamo considerare il salvataggio di un nuovo record (l'oggetto) nella tabella Post (la classe).

Chiaramente la creazione di un oggetto Post comprende l'assegnazione alle proprietà text ed image di due elementi del form (il secondo argomento del metodo form_valid) dall'insieme "cleaned_data" il quale contiene "text" e "image" che provengono stavolta dalla classe PostForm, che abbiamo definito  nel file form.py .

Una volta creato l'oggetto, il form richiama la url tramite il metodo ereditato form_valid() che restituisce a sua volta un HttpResponse con l'URL da richiamare in caso di successo.


Ora andiamo a creare il file "new_post.html" da posizionare nella cartella .../Hello/templates  e che conterrà fisicamente il form che verrà presentato all'utente. Anche stavolta ci appoggiamo al template di base.

	{% extends "base.html" %}

	{% block titolo %}Inserimento nuovo post{% endblock %}

	{% block corpoPagina %} 
		<form method="POST" action="" enctype="multipart/form-data">
			{% csrf_token %}
			{{ form.as_p }}
			<div>
				<button type="submit">Conferma</button>
			</div> 
		</form>
	{% endblock %}	

Il form di tipo "POST", lo ricordiamo, trasmette i dati all'interno della HTTP request, mentre l'altra opzione "GET" trasmette i dati attraverso la URL; è dunque chiaro che i dati di una immagine NON possono essere trasmessi attraverso una url: semplicemente tutti i dati non entrerebbero nella url.

Quello che conta è invece il parametro  enctype  che è impostato su "multipart/form-data" per consentire al form di codificare correttamente i dati binari delle immagini per poter poi essere elaborate dal form e, nel caso specifico, dal sistema di Django.

Subito dopo il token troviamo il tag personalizzato che fa riferimento all'oggetto form, che troviamo nella documentazione di FormView, alla descrizione del metodo get_context_data() che a sua volta richiama get_form() e dunque, senza complicarci la vita, possiamo usare "form" come elemento da usare nel tag, mostrato questa volta in forma di paragrafo (.as_p).

Dobbiamo ora inserire la nostra pagina fra le url operative della App feed.  Apriamo quindi .../Hello/feed/urls.py ed aggiungiamo la url della nostra nuova pagina, dove andiamo ad usare la classe AddPostView(), dopo averla opportunamente importata.

	from .views import HomePageView, PostDetailView, AddPostView
	....
	urlspatterns = [
		....
		path('post/', AddPostView.as_view(), name='post'),
	]
	
Possiamo visualizzare la nostra pagina con l'url "localhost:8000/post", ma possiamo fare qualcosa di meglio: inserire un link che la richiami all'intenro della stessa homepage; aggiungiamo una riga all'inizio del nostro blocco di corpo pagina del file .../Hello/templates/home.html:

	.....
	{% block corpoPagina %} 

		<a href="{% url 'feed:post' %}"> Inserisci un nuovo post &rarr </a>
		<hr>

		{% for post .....
			......
		{% endfor %}
	{% endblock %}

Andiamo cioè con HTML a creare un semplice riferimento ad una pagina esterna sfruttando ancora la funzione url.

Avviando la homepage siamo in grado di richiamare la pagina che contiene il form ed inserire nuovi post; ogni nuovo post si aggiungerà di volta in volta a quelli già esistenti.


Sessioni e Gestione dei messaggi
--------------------------------

Prima di eseguire ulteriori migliorie alla nostra app, facciamo chiarezza sul concetto di SESSIONI, che descriviamo così come definito da Google Analytics

Le sessioni (dette anche visite) sono un gruppo di interazioni che un utente compie con il sito web in un determinato arco di tempo o all'intero di una campagna. All’interno di una sessione, un utente può compiere diverse azioni, come visualizzare una o più pagine, iscriversi alla newsletter, compilare una richiesta di informazioni oppure, nel caso di un e-commerce, effettuare un acquisto.

In altri termini possiamo considerare la sessione come un contenitore per le azioni intraprese da un utente sul sito.

Un singolo utente può aprire più sessioni, che possono verificarsi nello stesso giorno o nell'arco di diversi giorni, settimane o mesi e al termine di una sessione, esiste l'opportunità di iniziare una nuova sessione. 

Esistono due tipi di sessioni distinte in base al tipo di scadenza che può essere...

 - Basata sul tempo (dopo 30 minuti o a mezzanotte)
 - Per cambio di campagna (es. accesso da link o da motore di ricerca)


Lo scopo che ci prefiggiamo in questo paragrafo è quello di gestire un messaggio di avvenuta registrazione all'interno della homepage e lo faremo attraverso la gestione della sessione.

Su https://docs.djangoproject.com/en/3.2/ref/contrib/messages/ la gestione dei messaggi è ben documentata e vale la pena darci una buona lettura per comprendere i prossimi passaggi.

Per prima cosa apriamo il file .../Hello/feed/views.py  ed inseriamo il seguente codice a quello esistente:

	from django.contrib import messages
	.....
	
	class AddPostView(FormView):       # esistente

		def dispatch(self, request, *args, **kwargs):
			self.request = request
			return super().dispatch(request, *args, **kwargs)

		def form_valid(self, ......
			......
			messages.add_message(self.request, messages.SUCCESS, 'Post registrato!')
			return ....
	....

L'import che abbiamo messo all'inizio sfrutta quello che esiste già in Django e definito nel file .../Hello/Hello/settings.py sia nella sessione MIDDLEWARE sia in TEMPLATE / OPTIONS / context_processors.  Questo significa è aggiunto a qualsiasi template automaticamente.

Abbiamo bisogno di aggiungere nella classe AddPostView() un riferimento a request che è un riferimento, un handle alla pagina html, proprio nel momento in cui questa viene creata (stati di "on_create" dei vecchi linguaggi ad eventi).

In modo furbo creiamo un metodo in overload che si "ruba" il valore di request che gli arriva come parametro e poi "fa passare" l'evento dispatch() originario della classe per non "bloccare" l'esecuzione della stessa.

Andiamo a modificare il metodo form_valid() aggiungendo un messaggio di tipo SUCCESS all'interno dei messaggi della nostra sessione. 

A tal proposito, nella documentazione ufficiale di "contrib/messages" troviamo una indicazione sui vari livelli di messaggio che possiamo creare:

	DEBUG	 messaggio ad uso degli sviluppatori
	INFO	 messaggio di tipo informativo
	SUCCESS	 messaggio di avvenuta azione
	WARNING	 messaggio di avvertimento
	ERROR	 messaggio di errore

Anzichè usare il metodo add_message() possiamo usare dei metodi diretti legati all'ggetto messages:

	messages.debug(request, '%s SQL statements were executed.' % count)
	messages.info(request, 'Three credits remain in your account.')
	messages.success(request, 'Profile details updated.')
	messages.warning(request, 'Your account expires in three days.')
	messages.error(request, 'Document deleted.')

L'uso del template dei messaggi è opportuno soprattutto se si intende usare Bootstrap (ne parleremo nel prossimo capitolo).

Per usare un messaggio possiamo copiare/incollare il codice che ci viene suggerito nella pagina di documentazione di django in forma di tag template; cosa che facciamo andando ad inserire proprio questo codice NON nella homepage, ma all'interno del template di base .../Hello/templates/base.html

Il blocco è costituito da un  {% if message %} ... {% endif %}  che attiva un ciclo di lettura di tutti i messaggi presenti nella sessione, SE presenti e li presenta (possiamo avere più di un messaggio) sotto forma di elenco puntato.

	<!DOCTYPE html>
	...........
	
	<body>
		{% if messages %}
			<ul class="messages">
				{% for message in messages %}
					<li{% if message.tags %} class="{{ message.tags }}"{% endif %}>{{ message }}</li>
				{% endfor %}
			</ul>
		{% endif %}
		.............
	</body>
	
	</html>

