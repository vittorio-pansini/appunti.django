**********************************
 Appendice C - Tricks
			   [0.2.0]
*********************************


[.] Rimuovere l'errore dell'icona mancante
------------------------------------------

Se all'avvio compare l'errore ...

	Not Found: /favicon.ico

... vuol dire che Django non trova l'icona giusta da mettere nella barra del browser insieme al titolo.

Per risolvere l'anomalia e far comparire una icona personalizzata della pagina, inserire nella sezione <head>, subito prima del titolo un'istruzione come nell'esempio che segue:

	<link rel="icon" href="{% static 'img/mioLogo.svg' %}">

... che fa riferimento ad una immagine mioLogo.svg gestita nel percorso statico.

Tuttavia un metodo ancora più efficace è quello di inserire il favicon fra le url del progetto.

Diamo per assunto che i file statici sinao stati configurati correttamente; andiamo ad aggiungere il seguente codice al file url.py della root:

	.....
	from django.contrib.staticfiles.storage import staticfiles_storage
	from django.views.generic.base import RedirectView

	urlpatterns = [ .....,
		 path('favicon.ico', RedirectView.as_view(url=staticfiles_storage.url('img/mioLogo.svg'))),
		 ......	]

In questo modo andiamo a risolvere la richiesta dei browser di avere il favicon.ico


[.] Superare l'errore "1048 last_login cannot be null" in MySQL
---------------------------------------------------------------

Durante la creazione di un utente administrator può verificarsi il seguente errore:

	django.db.utils.IntegrityError: (1048, "Column 'last_login' cannot be null")

... e la conseguente NON creazione dell'utente administrator.

Per risolvere il problema bisogna operare alcune operazioni manuali; per prima cosa in MySQL contolliamo il contenuto di django_migrations:

	mysql> USE miodatabase;
	mysql> SELECT * FROM django_migrations;

Se troviamo dentro dei record, allora cancelliamoli:

	mysql> TRUNCATE TABLE django_migrations;

Lasciamo il terminale di MySQL e rilanciamo le migrazioni in Django:

	$ python manage.py migrate --fake-initial

... ed accertiamoci che compaia il messaggio:

	0005_alter_user_last_login_null - [OK]

Se vediamo altri conflitti, è corretto perchè abbiamo bisogno di fare solo questa migrazione.


[.] Installare una libreria sotto Pycharm
-----------------------------------------

Menu di Pycharm  File/Settings(Ctrl+Alt+S) che farà apparire la finestra delle impostazioni.

Aprire il nodo  "> Project: {nome progetto}" e scegliere "Python interpreter"; fare click su "+" e cercare il nome della libreria da installare, ad esempio "Pillow".

In basso è possibile specificare la versione o lasciare che sia caricata quella corrente.

Fare click su "Install Package" e attendere che sia installato il pacchetto, quando comparirà il messaggio di avvenuta installazione.

[.] Rimuovere l'errore models.W042
----------------------------------

Se all'avvio compare nella console un messaggio del tipo ...

	" WARNINGS: {nometabella/modello}: (models.W042) Auto-created primary key used when not defining a primary key type, by default 'django.db.models.AutoField'. HINT: Configure the DEFAULT_AUTO_FIELD setting or the ReviewsConfig.default_auto_field attribute to point to a subclass of AutoField, ...."

... il motivo  è che si è creato un modello (ovvero una tabella) che non ha chiave primaria oppure che la chiave esterna usata per collegare due classi non è primaria.

Per risolvere o si rende la chiave usata primaria o si aggiunge in settings.py la seguente riga...

	DEFAULT_AUTO_FIELD='django.db.models.AutoField'
	
... oppure, ancora meglio ...

	DEFAULT_AUTO_FIELD='django.db.models.BigAutoField'

... che in realtà dalla versione 3.2 è il valore di default.

Questa è la soluzione generica, tuttavia il problema può permanere nel caso in cui un determinato modello (tabella) di una determinata app continua a mantenere "AutoField" come indice automatico mentre si sceglie di creare "BigAutoField" in automatico nel proprio progetto.

La soluzione è raggiungere il file  apps.py  all'interno dell'app interessata e modificarla in modo da "forzare" questa variabile esclusivamente per quella app e non per tutto il progetto.

Un problema del genere si è presentato quando ho importato la app 'django_simple_cookie_consent', che, rispetto a Django 4.0 in uso, era scritta per funzionare con versioni precedenti alla 3.1; nel caso specifico il codice in apps.py che è contenuto nel percorso {virualenv_path}\Lib\site-packages\django_simple_cookie_consent che era ...

	from django.apps import AppConfig

	class DjangoSimpleCookieConsentConfig(AppConfig):
		name = 'django_simple_cookie_consent'

... è stato modificato in ...

	from django.apps import AppConfig

	class DjangoSimpleCookieConsentConfig(AppConfig):
		default_auto_field = 'django.db.models.AutoField'
		name = 'django_simple_cookie_consent'

... aggiungendo quindi la definizione di default_auto_field dentro la classe che definisce il modello in uso.

Ricordarsi di eseguire l'azione di migrate per allineare la app al progetto: si noterà la scomparsa del warning.


[.] Errori durante l'esecuzione del migrate con mySQL
-----------------------------------------------------

Nell'eseguire il migrate nell'ambiente production (capitolo 15) si verificano i seguenti errori:

(.) Primo errore: 

	Collecting mysqlclient==2.1.0
	  Using cached mysqlclient-2.1.0.tar.gz (87 kB)
		ERROR: Command errored out with exit status 1:
		.......
	ERROR: Command errored out with exit status 1: 
		python setup.py egg_info Check the logs for full command output.

Significa che bisogna installare django-mysql nell'ambiente virtuale di esecuzione.

	()$ python -m pip install django-mysql


(.) Secondo errore:

	(awebenv) agenziaweb@ubuntu:~/AGENZIAW$ python3 manage.py migrate
	Traceback (most recent call last):
		......
	' in module 'AGENZIAW':  module 'AGENZIAW.settings' has no attribute 'Prod

Le variabili di ambiente sono state troncate; anzichè leggere 'Prod' (cioè aperti e chiusi apici) l'apice di chiusura è stato troncato; motivo: è stato generato il file di testo per passare le variabili di ambiente con Windows e poi è stato esguito in Linux.  Questa cosa NON funzionerà mai. Va creato file tutto nuovo DENTRO Linux e scritta riga per riga tutto il contenuto, altrimenti Linux tronca e fa casino con la lettura del file.


(.) Terzo errore:

	Traceback (most recent call last):
		.......
	django.db.utils.ProgrammingError: (1102, "Incorrect database name 'AgenziaWeb\r'")

Stessa causa del secondo errore, solo che questa volta viene aggiunto "\r" il carrige return in più. Stessa soluzione.


La console di Django da errore django.core.exceptions.ImproperlyConfigured
--------------------------------------------------------------------------

Premessa: si sta lavorando su un progetto Django che è stato perfezionato per funzionare con nginx e gunicorn, ma improvvisamente la console di Python smette di funzionare e compare il seguente errore:

	Traceback (most recent call last):
	  File "C:\Python39\lib\code.py", line 90, in runcode
		exec(code, self.locals)
	  File "<input>", line 6, in <module>
	  File "D:\PROGETTI\DJANGO\AWEBENV\lib\site-packages\django\__init__.py", line 19, in setup
		configure_logging(settings.LOGGING_CONFIG, settings.LOGGING)
	  File "D:\PROGETTI\DJANGO\AWEBENV\lib\site-packages\django\conf\__init__.py", line 84, in __getattr__
		self._setup(name)
	  File "D:\PROGETTI\DJANGO\AWEBENV\lib\site-packages\django\conf\__init__.py", line 71, in _setup
		self._wrapped = Settings(settings_module)
	  File "D:\PROGETTI\DJANGO\AWEBENV\lib\site-packages\django\conf\__init__.py", line 179, in __init__
		mod = importlib.import_module(self.SETTINGS_MODULE)
	  File "C:\Python39\lib\importlib\__init__.py", line 127, in import_module
		return _bootstrap._gcd_import(name[level:], package, level)
	  File "<frozen importlib._bootstrap>", line 1030, in _gcd_import
	  File "<frozen importlib._bootstrap>", line 1007, in _find_and_load
	  File "<frozen importlib._bootstrap>", line 986, in _find_and_load_unlocked
	  File "<frozen importlib._bootstrap>", line 680, in _load_unlocked
	  File "<frozen importlib._bootstrap_external>", line 790, in exec_module
	  File "<frozen importlib._bootstrap>", line 228, in _call_with_frames_removed
	  File "D:\PROGETTI\DJANGO\AGENZIAW\AGENZIAW\settings.py", line 17, in <module>
		class Dev(Configuration):
	  File "D:\PROGETTI\DJANGO\AWEBENV\lib\site-packages\configurations\base.py", line 27, in __new__
		raise ImproperlyConfigured(install_failure)
	django.core.exceptions.ImproperlyConfigured: django-configurations settings importer wasn't correctly installed. Please use one of the starter functions to install it as mentioned in the docs: https://django-configurations.readthedocs.io/

Per far funzionare di nuovo la console, va riconfigurato il sistema di caricamento della console stessa; dal menu File selezioniamo Settings (Ctrl+Alt+S) e poi seguiamo il percorso [Build, Execution, Deployment] > [Console] > [Django Console]

Nella finestra aggiungere in "Environment variables" le variabili che interessano il nostro progetto:

	DJANGO_CONFIGURATION=Dev;DJANGO_SETTINGS_MODULE=AGENZIAW.settings;PYTHONUNBUFFERED=1

Quindi andiamo a modificare lo "Starting script" da ....

	import sys; print('Python %s on %s' % (sys.version, sys.platform))
	import django; print('Django %s' % django.get_version())
	sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])
	if 'setup' in dir(django): django.setup()
	import django_manage_shell; django_manage_shell.run(PROJECT_ROOT)

... a ...

	import sys; print('Python %s on %s' % (sys.version, sys.platform))
	import django; print('Django %s' % django.get_version())
	sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])
	# ---------------------------------------------------------------
	import configurations
	configurations.setup()
	# ---------------------------------------------------------------
	if 'setup' in dir(django): django.setup()
	import django_manage_shell; django_manage_shell.run(PROJECT_ROOT)

... cioè aggiungendo l'importazione di configurations e la sua attivazione.

Perchè la modifica abbia effetto è necessario riavviare Pycharm.

